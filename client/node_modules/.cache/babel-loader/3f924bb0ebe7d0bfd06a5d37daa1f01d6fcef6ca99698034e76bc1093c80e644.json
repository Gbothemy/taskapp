{"ast":null,"code":"import _objectSpread from\"C:/Users/HP/Desktop/TPAY/client/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";import{createSlice,createAsyncThunk}from'@reduxjs/toolkit';import axios from'axios';// Create a separate API instance to avoid circular dependency\nconst taskApi=axios.create({baseURL:process.env.REACT_APP_API_URL||'http://localhost:5000/api',headers:{'Content-Type':'application/json'}});// Add token interceptor\ntaskApi.interceptors.request.use(config=>{const token=localStorage.getItem('accessToken');if(token){config.headers.Authorization=\"Bearer \".concat(token);}return config;});// Async thunks\nexport const fetchTasks=createAsyncThunk('tasks/fetchTasks',async function(){let params=arguments.length>0&&arguments[0]!==undefined?arguments[0]:{};let{rejectWithValue}=arguments.length>1?arguments[1]:undefined;try{const response=await taskApi.get('/tasks',{params});return response.data;}catch(error){var _error$response,_error$response$data;return rejectWithValue(((_error$response=error.response)===null||_error$response===void 0?void 0:(_error$response$data=_error$response.data)===null||_error$response$data===void 0?void 0:_error$response$data.message)||'Failed to fetch tasks');}});export const fetchTaskById=createAsyncThunk('tasks/fetchTaskById',async(taskId,_ref)=>{let{rejectWithValue}=_ref;try{const response=await taskApi.get(\"/tasks/\".concat(taskId));return response.data.task;}catch(error){var _error$response2,_error$response2$data;return rejectWithValue(((_error$response2=error.response)===null||_error$response2===void 0?void 0:(_error$response2$data=_error$response2.data)===null||_error$response2$data===void 0?void 0:_error$response2$data.message)||'Failed to fetch task');}});export const createTask=createAsyncThunk('tasks/createTask',async(taskData,_ref2)=>{let{rejectWithValue}=_ref2;try{const response=await taskApi.post('/tasks',taskData);return response.data.task;}catch(error){var _error$response3,_error$response3$data;return rejectWithValue(((_error$response3=error.response)===null||_error$response3===void 0?void 0:(_error$response3$data=_error$response3.data)===null||_error$response3$data===void 0?void 0:_error$response3$data.message)||'Failed to create task');}});export const submitTask=createAsyncThunk('tasks/submitTask',async(_ref3,_ref4)=>{let{taskId,proofData}=_ref3;let{rejectWithValue}=_ref4;try{const response=await taskApi.post(\"/tasks/\".concat(taskId,\"/submit\"),{proofData});return response.data.submission;}catch(error){var _error$response4,_error$response4$data;return rejectWithValue(((_error$response4=error.response)===null||_error$response4===void 0?void 0:(_error$response4$data=_error$response4.data)===null||_error$response4$data===void 0?void 0:_error$response4$data.message)||'Failed to submit task');}});export const fetchMyTasks=createAsyncThunk('tasks/fetchMyTasks',async(_,_ref5)=>{let{rejectWithValue}=_ref5;try{const response=await taskApi.get('/tasks/my/tasks');return response.data.tasks;}catch(error){var _error$response5,_error$response5$data;return rejectWithValue(((_error$response5=error.response)===null||_error$response5===void 0?void 0:(_error$response5$data=_error$response5.data)===null||_error$response5$data===void 0?void 0:_error$response5$data.message)||'Failed to fetch my tasks');}});export const fetchMySubmissions=createAsyncThunk('tasks/fetchMySubmissions',async(_,_ref6)=>{let{rejectWithValue}=_ref6;try{const response=await taskApi.get('/tasks/my/submissions');return response.data.submissions;}catch(error){var _error$response6,_error$response6$data;return rejectWithValue(((_error$response6=error.response)===null||_error$response6===void 0?void 0:(_error$response6$data=_error$response6.data)===null||_error$response6$data===void 0?void 0:_error$response6$data.message)||'Failed to fetch submissions');}});const initialState={tasks:[],currentTask:null,myTasks:[],mySubmissions:[],pagination:{currentPage:1,totalPages:1,totalTasks:0,hasNext:false,hasPrev:false},filters:{category:'',minPayout:'',maxPayout:'',search:'',sortBy:'createdAt',sortOrder:'desc'},loading:false,error:null};const taskSlice=createSlice({name:'tasks',initialState,reducers:{setFilters:(state,action)=>{state.filters=_objectSpread(_objectSpread({},state.filters),action.payload);},clearCurrentTask:state=>{state.currentTask=null;},clearError:state=>{state.error=null;},updateTaskInList:(state,action)=>{const{taskId,updates}=action.payload;const taskIndex=state.tasks.findIndex(task=>task.id===taskId);if(taskIndex!==-1){state.tasks[taskIndex]=_objectSpread(_objectSpread({},state.tasks[taskIndex]),updates);}const myTaskIndex=state.myTasks.findIndex(task=>task.id===taskId);if(myTaskIndex!==-1){state.myTasks[myTaskIndex]=_objectSpread(_objectSpread({},state.myTasks[myTaskIndex]),updates);}},addSubmission:(state,action)=>{state.mySubmissions.unshift(action.payload);}},extraReducers:builder=>{builder// Fetch Tasks\n.addCase(fetchTasks.pending,state=>{state.loading=true;state.error=null;}).addCase(fetchTasks.fulfilled,(state,action)=>{state.loading=false;state.tasks=action.payload.tasks;state.pagination=action.payload.pagination;}).addCase(fetchTasks.rejected,(state,action)=>{state.loading=false;state.error=action.payload;})// Fetch Task By ID\n.addCase(fetchTaskById.pending,state=>{state.loading=true;state.error=null;}).addCase(fetchTaskById.fulfilled,(state,action)=>{state.loading=false;state.currentTask=action.payload;}).addCase(fetchTaskById.rejected,(state,action)=>{state.loading=false;state.error=action.payload;})// Create Task\n.addCase(createTask.pending,state=>{state.loading=true;state.error=null;}).addCase(createTask.fulfilled,(state,action)=>{state.loading=false;state.myTasks.unshift(action.payload);}).addCase(createTask.rejected,(state,action)=>{state.loading=false;state.error=action.payload;})// Submit Task\n.addCase(submitTask.pending,state=>{state.loading=true;state.error=null;}).addCase(submitTask.fulfilled,(state,action)=>{state.loading=false;state.mySubmissions.unshift(action.payload);}).addCase(submitTask.rejected,(state,action)=>{state.loading=false;state.error=action.payload;})// Fetch My Tasks\n.addCase(fetchMyTasks.fulfilled,(state,action)=>{state.myTasks=action.payload;})// Fetch My Submissions\n.addCase(fetchMySubmissions.fulfilled,(state,action)=>{state.mySubmissions=action.payload;});}});export const{setFilters,clearCurrentTask,clearError,updateTaskInList,addSubmission}=taskSlice.actions;export default taskSlice.reducer;","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}